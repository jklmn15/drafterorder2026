name: Fetch ASX Draft Data (from Google Sheet)

on:
  workflow_dispatch:
  schedule:
    - cron: "*/10 * * * *"   # every 10 minutes (UTC). Sydney logic handled in script.

permissions:
  contents: write

concurrency:
  group: asx-draft-data
  cancel-in-progress: false

jobs:
  fetch:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Node
        uses: actions/setup-node@v4
        with:
          node-version: "20"

      - name: Fetch CSV and write data.json
        env:
          CSV_URL: "https://docs.google.com/spreadsheets/d/e/2PACX-1vRYhwLaZvprnIRaCoGaqNuEgyHYqeUeXC6J4bG3wUhYWIy7e_gpFgvdqP15D1EqNw/pub?output=csv"
          # These should match your front-end tickers
          TICKERS: "CSL.AX,BHP.AX,WBC.AX,WES.AX,CBA.AX,RIO.AX,MQG.AX,NAB.AX"
        run: |
          node <<'NODE'
          const fs = require("fs");

          const CSV_URL = process.env.CSV_URL;
          const TICKERS = (process.env.TICKERS || "").split(",").map(s => s.trim()).filter(Boolean);

          // ===== Sydney time helpers =====
          function getSydneyNow() {
            const now = new Date();
            return new Date(now.toLocaleString("en-US", { timeZone: "Australia/Sydney" }));
          }
          function ymd(d) {
            const y = d.getFullYear();
            const m = String(d.getMonth()+1).padStart(2,"0");
            const day = String(d.getDate()).padStart(2,"0");
            return `${y}-${m}-${day}`;
          }
          function hhmm(d){
            const h = String(d.getHours()).padStart(2,"0");
            const m = String(d.getMinutes()).padStart(2,"0");
            return `${h}:${m}`;
          }
          function minutesSinceMidnight(d){
            return d.getHours()*60 + d.getMinutes();
          }

          // ASX lock at 16:05 Sydney
          const sydneyNow = getSydneyNow();
          const today = ymd(sydneyNow);
          const minutes = minutesSinceMidnight(sydneyNow);
          const LOCK_MINUTE = 16*60 + 5;
          const shouldLock = minutes >= LOCK_MINUTE;

          // If already locked for today with real data, skip
          let existing = null;
          try { existing = JSON.parse(fs.readFileSync("data.json","utf8")); } catch {}
          const existingHasData =
            existing &&
            existing.dateSydney === today &&
            Array.isArray(existing.quotes) &&
            existing.quotes.some(q => q && q.percentDay !== null);

          if (existing && existing.locked === true && existing.dateSydney === today && existingHasData) {
            console.log("Already locked for today with data. Skipping update.");
            process.exit(0);
          }

          // ===== CSV parsing (handles quotes/commas) =====
          function parseCSV(text){
            const rows = [];
            let row = [];
            let field = "";
            let inQuotes = false;

            for (let i = 0; i < text.length; i++){
              const c = text[i];
              const next = text[i+1];

              if (c === '"' ) {
                if (inQuotes && next === '"') { field += '"'; i++; }
                else { inQuotes = !inQuotes; }
              } else if (c === "," && !inQuotes) {
                row.push(field); field = "";
              } else if ((c === "\n" || c === "\r") && !inQuotes) {
                if (c === "\r" && next === "\n") i++;
                row.push(field); field = "";
                // ignore totally empty trailing lines
                if (row.length > 1 || (row.length === 1 && row[0].trim() !== "")) rows.push(row);
                row = [];
              } else {
                field += c;
              }
            }
            // last field
            if (field.length || row.length){
              row.push(field);
              if (row.length > 1 || (row.length === 1 && row[0].trim() !== "")) rows.push(row);
            }
            return rows;
          }

          function normalizeHeader(h){
            return String(h || "").trim().toLowerCase();
          }

          function toNumberMaybe(x){
            if (x === null || x === undefined) return null;
            const s = String(x).trim();
            if (!s) return null;

            // handle "1.23%", "+1.23", "-0.5"
            const cleaned = s.replace(/[%]/g, "").replace(/[,+]/g, "").trim();
            const n = Number(cleaned);
            return Number.isFinite(n) ? n : null;
          }

          async function fetchCSV(){
            const url = CSV_URL + (CSV_URL.includes("?") ? "&" : "?") + "ts=" + Date.now();
            const res = await fetch(url, { headers: { "User-Agent": "Mozilla/5.0 (GitHub Actions)" }});
            if (!res.ok) throw new Error("CSV fetch failed HTTP " + res.status);
            return await res.text();
          }

          function pickColumnIndex(headers, predicates){
            for (let i = 0; i < headers.length; i++){
              const h = normalizeHeader(headers[i]);
              if (predicates.some(p => p(h))) return i;
            }
            return -1;
          }

          function extractQuotesFromTable(rows){
            if (!rows || rows.length < 2) throw new Error("CSV appears empty");

            const headers = rows[0];

            // Try common header names
            const symIdx = pickColumnIndex(headers, [
              h => h === "symbol",
              h => h === "ticker",
              h => h.includes("symbol"),
              h => h.includes("ticker"),
              h => h.includes("code")
            ]);

            const pctIdx = pickColumnIndex(headers, [
              h => h.includes("%"),
              h => h.includes("percent"),
              h => h.includes("change"),
              h => h.includes("day"),
              h => h.includes("daily")
            ]);

            // If no headers match, fallback: symbol is first column, pct is last column
            const symbolCol = symIdx >= 0 ? symIdx : 0;
            const pctCol = pctIdx >= 0 ? pctIdx : (headers.length - 1);

            const map = new Map();

            for (let r = 1; r < rows.length; r++){
              const row = rows[r];
              const symbol = (row[symbolCol] || "").trim();

              // symbol sanity
              if (!symbol) continue;

              const pct = toNumberMaybe(row[pctCol]);

              // Store
              map.set(symbol, pct);
            }

            return map;
          }

          function buildOutputFromMap(symbolToPct){
            // Build quotes in the order of TICKERS
            const quotes = TICKERS.map(sym => ({
              symbol: sym,
              percentDay: symbolToPct.has(sym) ? symbolToPct.get(sym) : null,
              price: null,
              prevClose: null,
              timeEpoch: null
            }));

            const hasAnyData = quotes.some(q => q.percentDay !== null);
            if (!hasAnyData) {
              // Give a helpful error showing what symbols we DID see
              const seen = Array.from(symbolToPct.keys()).slice(0, 25);
              throw new Error(
                "No matching tickers found in CSV. Expected one of: " +
                TICKERS.join(", ") +
                ". Saw: " + seen.join(", ")
              );
            }

            return {
              dateSydney: today,
              lastUpdatedSydney: `${today} ${hhmm(sydneyNow)}`,
              locked: shouldLock,
              quotes
            };
          }

          async function main(){
            const csvText = await fetchCSV();
            const rows = parseCSV(csvText);

            const symbolToPct = extractQuotesFromTable(rows);
            const out = buildOutputFromMap(symbolToPct);

            // If we are after lock time but data is incomplete, still write but don't lock
            // (prevents locking junk)
            const completeEnough = out.quotes.filter(q => q.percentDay !== null).length >= Math.max(1, Math.floor(TICKERS.length * 0.75));
            if (out.locked && !completeEnough) {
              console.log("After lock time but data incomplete â€” writing unlocked snapshot.");
              out.locked = false;
            }

            fs.writeFileSync("data.json", JSON.stringify(out, null, 2));
            console.log("Wrote data.json", out.lastUpdatedSydney, "locked:", out.locked);
          }

          main().catch(err => {
            console.error(err);
            process.exit(1);
          });
          NODE

      - name: Commit and push if changed
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git add data.json
          git diff --cached --quiet || (git commit -m "Update ASX draft data" && git push)
